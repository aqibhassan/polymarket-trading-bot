"""Signal models — trading signal generation output."""

from __future__ import annotations

from datetime import UTC, datetime
from decimal import Decimal
from enum import Enum

from pydantic import BaseModel, Field

from src.models.market import Side  # noqa: TCH001 — Pydantic needs runtime access


class SignalType(str, Enum):
    ENTRY = "ENTRY"
    EXIT = "EXIT"
    SKIP = "SKIP"


class TrendDirection(str, Enum):
    UP = "UP"
    DOWN = "DOWN"
    NEUTRAL = "NEUTRAL"


class ExitReason(str, Enum):
    PROFIT_TARGET = "PROFIT_TARGET"
    TRAILING_STOP = "TRAILING_STOP"
    HARD_STOP_LOSS = "HARD_STOP_LOSS"
    MAX_TIME = "MAX_TIME"
    RESOLUTION_GUARD = "RESOLUTION_GUARD"
    KILL_SWITCH = "KILL_SWITCH"
    MANUAL = "MANUAL"


class Confidence(BaseModel):
    """Breakdown of signal confidence scoring."""

    trend_strength: float = 0.0
    threshold_exceedance: float = 0.0
    book_normality: float = 0.0
    liquidity_quality: float = 0.0
    overall: float = 0.0

    def meets_minimum(self, min_confidence: float) -> bool:
        return self.overall >= min_confidence

    model_config = {"frozen": True}


class Signal(BaseModel):
    """A trading signal generated by a strategy."""

    strategy_id: str
    market_id: str
    signal_type: SignalType
    direction: Side
    strength: Decimal = Decimal("0")
    confidence: Confidence = Field(default_factory=Confidence)
    entry_price: Decimal | None = None
    stop_loss: Decimal | None = None
    take_profit: Decimal | None = None
    exit_reason: ExitReason | None = None
    metadata: dict[str, str] = Field(default_factory=dict)
    timestamp: datetime = Field(default_factory=lambda: datetime.now(tz=UTC))

    model_config = {"frozen": True}


class TrendResult(BaseModel):
    """Result of BTC trend analysis."""

    direction: TrendDirection
    strength: float = Field(ge=0.0, le=1.0)
    momentum: float = 0.0
    green_count: int = 0
    red_count: int = 0
    cumulative_move_pct: float = 0.0

    model_config = {"frozen": True}
